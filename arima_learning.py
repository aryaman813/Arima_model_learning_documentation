# -*- coding: utf-8 -*-
"""ARIMA Learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12KXxsgJimYR4mnGw4tbZNZJUzYFOdHnU
"""

# importing dependencies

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import yfinance as yf
import warnings
warnings.filterwarnings("ignore")

start = "2015-01-01"
end = "2024-01-01"
stock = "AAPL"

data = yf.download(stock, start=start, end=end, auto_adjust=False, multi_level_index=False)

df = data.copy()
df.isnull().values.any()
df = df.dropna()

data

df2 = data["Volume"]
df2

high_open = data[data["Open"] >= 80]
high_open

# importing dependencies

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import yfinance as yf
import warnings
warnings.filterwarnings("ignore")

df = data.copy()
df.isnull().values.any()
df = df.dropna()

df.head()

# 1-day lag plot

import plotly.graph_objects as go

# make a copy of the data

data = df.copy()

data["Lagged Close"] = data["Close"].shift(1)

fig = go.Figure(data=go.Scatter(x=data["Close"], y=data["Lagged Close"], mode="markers"))

fig.update_layout(
    title=f"Lag Plot of {stock} Closing Prices with a 1-Day Lag",
    xaxis_title="Todays Close",
    yaxis_title="Previous Days Close",
    template="plotly_dark"
)

fig.show()

# 5-day lag plot

import plotly.graph_objects as go

# make a copy of the data

data = df.copy()

data["Lagged Close"] = data["Close"].shift(5)

fig = go.Figure(data=go.Scatter(x=data["Close"], y=data["Lagged Close"], mode="markers"))

fig.update_layout(
    title=f"Lag Plot of {stock} Closing Prices with a 5-Day Lag",
    xaxis_title="Todays Close",
    yaxis_title="Previous Days Close",
    template="plotly_dark"
)

fig.show()

# train & testing data

train_data = df.iloc[0:int(len(data)*0.8), :]
test_data = df.iloc[int(len(data)*0.8):, :]

fig = go.Figure()

fig.add_trace(go.Scatter(x=train_data.index, y=train_data["Open"], mode="lines", name="Training Data", line=dict(color="blue")))
fig.add_trace(go.Scatter(x=test_data.index, y=test_data["Open"], mode="lines", name="Testing Data", line=dict(color="green")))

fig.update_layout(
    title=f"{stock} Open Prices, Training and Testing Data",
    xaxis_title="Dates",
    yaxis_title="Open Prices",
    template="plotly_dark"
)

fig.show()

window = 7
train_series = train_data["Open"]

# Determining the rolling statistics
rolmean = train_series.rolling(window).mean()
rolstd = train_series.rolling(window).std()

# plot rolling statistics
fig = plt.figure(figsize=(10,6))
orig = plt.plot(train_series, color="blue", label="Original")
mean = plt.plot(rolmean, color="red", label="Rolling Mean")
std = plt.plot(rolstd, color="black", label="Rolling Std")
plt.legend(loc="best")
plt.title("Rolling Mean & Standard Deviation")

from statsmodels.tsa.stattools import adfuller

window = 7
train_series = train_data['Close']

dftest = adfuller(train_series, autolag='AIC')
dfoutput = pd.Series(dftest[0:4], index=['Test Statistic', 'p-value','#Lags Used','Number of Observations Used'])
for key, value in dftest[4].items():
  dfoutput['Critical Value (%s)'%key] = value
dfoutput

# Calculate the difference between the consecutive elements and dropping any NaN values
train_diff = train_series.diff(periods=1)
train_diff = train_diff.dropna(inplace = False)

window = 7

# Determining the rolling statistics
rolmean = train_diff.rolling(window).mean()
rolstd = train_diff.rolling(window).std()

# plot rolling statistics
fig = plt.figure(figsize=(10,6))
orig = plt.plot(train_diff, color="blue", label="Original")
mean = plt.plot(rolmean, color="red", label="Rolling Mean")
std = plt.plot(rolstd, color="black", label="Rolling Std")
plt.legend(loc="best")
plt.title("Rolling Mean & Standard Deviation")

dftest = adfuller(train_diff, autolag='AIC')
dfoutput = pd.Series(dftest[0:4], index=['Test Statistic', 'p-value','#Lags Used','Number of Observations Used'])
for key, value in dftest[4].items():
  dfoutput['Critical Value (%s)'%key] = value
dfoutput

def smape_kun(y_true, y_pred, epsilon=1e-8):
  # Calculate the denominator to avoid division by zero
  denominator = (np.abs(y_pred) + np.abs(y_true)) + epsilon

  # Compute the absolute percentage error with symmetric scaling
  absolute_percentage_error = np.abs(y_pred - y_true) * 200 / denominator

  # Calculate the mean of the symmetric absolute percentage errors
  mean_smape = np.mean(absolute_percentage_error)

  return mean_smape

test_series = test_data["Close"]
test_diff = test_series.diff(periods=1)
test_diff = test_diff.dropna(inplace = False)

"""Modelling"""

from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error

# initialize the history with our training data
history = [x for x in train_diff]
predictions = list()

# iterate through the test data points
for t in range(len(test_diff)):
    p, d, q = 5, 1, 0
    model = ARIMA(history, order=[p, d, q])
    model_fit = model.fit()

    output = model_fit.forecast()
    yhat = output[0]
    predictions.append(yhat)

    obs = test_diff[t]
    history.append(obs)

    if t % 100 == 0:
      print('Test Series Point: {}\tPredicted={}. Expected={}'.format(t, yhat, obs))

  # Calculate MSE to determine if model performed well

mse = mean_squared_error(test_diff, predictions)
print("Mean Squared Error (MSE): ", mse)

# Calculate cumulative sum

reverse_test_diff = np.r_[test_series.iloc[0], test_diff].cumsum()
reverse_predictions = np.r_[test_series.iloc[0], predictions].cumsum()
reverse_test_diff.shape, reverse_predictions.shape

# Calculate error

error = mean_squared_error(reverse_test_diff, reverse_predictions)
error_smape = smape_kun(reverse_test_diff, reverse_predictions)

print("Testing MSE: %.3f" % error)
print("Testing SMAPE: %.3f" % error_smape)

# take the reverse_test_diff and reverse_predictions, convert them to a pandas series, set their indices to a existing time series

reverse_test_diff_series = pd.Series(reverse_test_diff)
reverse_test_diff_series.index = test_series.index

reverse_predictions_series = pd.Series(reverse_test_diff)
reverse_predictions_series.index = test_series.index

# plotting

plt.figure(figsize=(12, 6))
plt.title("AAPL Closing Prices")
plt.xlabel("Dates")
plt.ylabel("Prices")
plt.plot(train_series, color="blue", label='Training Prices')
plt.plot(reverse_test_diff_series, color="green", marker=".", label="Testing Prices - Reverse Diff Transform")
plt.plot(reverse_test_diff_series, color="red", linestyle="--", label="Forecasted Price - Reverse Diff Transoform")
plt.legend()

plt.figure(figsize=(12, 7))
plt.title('AAPL Prices (Test / Forecast)')
plt.xlabel('Dates')
plt.ylabel('Prices')
plt.plot(reverse_test_diff_series, color='green', marker='.', label='Testing Prices - Reverse Diff Transform')
plt.plot(reverse_test_diff_series, color='red', linestyle="--", label='Forecaseted Prices - Reverse Diff Transform')
plt.legend();

